<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据库</title>
    <url>/2021/AEMVFQ/</url>
    <content><![CDATA[<h1 id="数据库索引机制"><a href="#数据库索引机制" class="headerlink" title="数据库索引机制"></a>数据库索引机制</h1><p><strong>1、为什么要使用索引</strong></p>
<p>因为数据库的数据是存放在磁盘上的，如果需要查找数据，需要去磁盘上一个一个比对，磁盘的IO消耗了大量的时间。</p>
<p>如果建立了目标字段到磁盘地址的索引，那么就能很快的找到数据</p>
<p><img src="evernotecid://6028B529-0AB8-4743-BD04-3B9B649D5196/appyinxiangcom/8900893/ENResource/p224" alt="b373687b7062b601d4ad681a4b612ae3.png"></p>
<p><strong>2、数据库索引</strong></p>
<p>1)、普通索引</p>
<p>create index index_name on table(column)</p>
<p>2)、唯一索引</p>
<p>create unique index index_name on table(column)</p>
<p>索引列的值必须唯一。可以为空，这点区别主键索引</p>
<p>3)、主键索引</p>
<p>特殊的唯一索引，不可以为空，只能有一个</p>
<p>4)、组合索引</p>
<p>create index index_name on table(a,b,c)</p>
<p>在多字段上建立索引，遵循最左前缀原则</p>
<p>最左前缀原则：</p>
<p>(1) 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,c,d的顺序可以任意调整。</p>
<p>(2) =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，即b=2 and a=1 and c=3也可以用到索引，mysql的查询优化器会帮你优化成索引可以识别的形式</p>
<p>（3）如果（a，b，c)建立索引，那么where a =1 and c =3，只能用到a的索引。</p>
<p>5)、全文索引</p>
<p><strong>3、何时使用索引</strong></p>
<p>Mysql查询时只使用一种索引，与其说Mysql只能使用一种索引，倒不如说，和全表扫描比起来，去分析两个索引B+树更加消耗时间，所以where A=a and B=b 使用组合索引最佳，B+树根据（A，B）排序</p>
<p>(1) 主键，unique字段</p>
<p>(2) 和其他表做连接的字段需要加索引</p>
<p>(3) 在where里面使用&gt; &lt; = is null 和betweent的字段</p>
<p>(4) 使用不以通配符开始的like where A like ‘China%’；</p>
<p>(5) 聚集函数MIN(),MAX()的字段</p>
<p>(6) order by 和 group by 字段</p>
<p><strong>4、何时不使用索引</strong></p>
<p>(1) 表记录太少</p>
<p>(2) 数据重复且分布比较平均的列</p>
<p>(3) 经常插入、删除、修改的列</p>
<p>(4) text、imgae类型不适合做索引，因为数据量太大</p>
<p>(5) Mysql能估计出全表所描比使用索引快，不使用索引</p>
<p><strong>5、何时索引失效</strong></p>
<p>(1) 组合索引未使用最左前缀 例如组合索引（A，B），where B=b不会使用索引。</p>
<p>(2) like未使用最左前缀 where A like ‘%China’</p>
<p>(3) 搜索一个索引而另一个索引使用order by，where A=a order by B,只使用A上的索引，因为查询只使用一个索引</p>
<p>(4) or会使索引失效。如果查询字段相同，也可以使用索引。例如where A=a1 or A=a2（生效），where A=a or B=b（失效）</p>
<p>(5) 如果列类型是字符串，要使用引号。例如where A=’China’，否则索引失效（会进行类型转换）</p>
<p>(6) 在索引列上的操作，函数（upper()等）、or、！=(&lt;&gt;)、not in等；</p>
<p><strong>5、Mysql Join的用法</strong></p>
<p>几种join：</p>
<p>(1) 笛卡尔积：CROSS JOIN</p>
<p>将A表的记录与B表的记录强行拼接在一起，例如A表有m条记录，B表有n条记录，那么笛卡尔积产生的结果就会有m * n 条记录。</p>
<p>几种产生笛卡尔积的方法：</p>
<p>SELECT * FROM t_blog CROSS JOIN t_type;</p>
<p>SELECT * FROM t_blog INNER JOIN t_type;</p>
<p>SELECT * FROM t_blog,t_type;</p>
<p>SELECT * FROM t_blog NATURE JOIN t_type;</p>
<p>(2) 内连接：INNER JOIN</p>
<p>从数学的角度就是求两个表的交集，从笛卡尔积的角度就是从笛卡尔积中跳出ON条件成立的记录，有INNER JOIN，WHERE（等值连接），STRAIGHT_JOIN,JOIN(省略INNER)四种写法。</p>
<p>几种内连接的方法：</p>
<p>select * from t_blog inner join t_type on t_blog.typeId=t_type.id;</p>
<p>select * from t_blog,t_type where t_blog.typeId=t_type.id;</p>
<p>select * from t_blog straight_join t_type on t_blog.typeId = t_type.id;</p>
<p>select * from t_blog join t_type on t_blog.typeId = t_type.id;</p>
<p>(3)左连接: left join</p>
<p>左连接LEFT JOIN的含义就是求两个表的交集外加左表剩下的数据。依旧从笛卡尔积的角度讲，就是先从笛卡尔积中挑出ON子句条件成立的记录，然后加上左表中剩余的记录</p>
<p>select * from t_blog left join t_type on t_blog.typeId=t_type.id;</p>
<p>(4)右连接:rigth join</p>
<p>同理右连接RIGHT JOIN就是求两个表的交集外加右表剩下的数据。再次从笛卡尔积的角度描述，右连接就是从笛卡尔积中挑出ON子句条件成立的记录，然后加上右表中剩余的记录。</p>
<p>select * from t_blog right join t_type on t_blog.typeId = t_type.id;</p>
<p>(5)外连接：outer join</p>
<p>外连接就是求两个集合的并集。从笛卡尔积的角度讲就是从笛卡尔积中挑出ON子句条件成立的记录，然后加上左表中剩余的记录，最后加上右表中剩余的记录。另外MySQL不支持OUTER JOIN，但是我们可以对左连接和右连接的结果做UNION操作来实现。</p>
<p>select * from t_blog left join t_type on t_blog.typeId=t_type.id union select * from t_blog right join t_type on t_blog.typeId = t_type.id;</p>
<p>(6)自然连接：natural join</p>
<p>自然连接就是USING子句的简化版，它找出两个表中相同的列作为连接条件进行连接。有左自然连接，右自然连接和普通自然连接之分。在t_blog和t_type示例中，两个表相同的列是id，所以会拿id作为连接条件。</p>
<p>另外千万分清下面两条语句的区别 。</p>
<p>自然连接:SELECT * FROM t_blog NATURAL JOIN t_type;</p>
<p>笛卡尔积:SELECT * FROM t_blog NATURA JOIN t_type;</p>
<p>**<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">6、Mysql索引背后的数据结构和算法原理**</a></p>
<p>由于索引本身比价大，不可能全部存储在内存中，所以索引会以索引文件的形式存储在磁盘中，这样索引过程就需要进行磁盘I/O，磁盘IO的消耗要比内存存取高几个数量级，所以，一般使用磁盘IO的次数评价索引结构的优劣。</p>
<p>MyISAM与InnoDB的区别：</p>
<p>（1）MyISAM B+树叶子节点存储的是数据的地址，InnoDB存储的是完整的数据。</p>
<p>（2）InnoDB辅助索引的data域存储相应记录主键的值而不是地址。</p>
<p><a href="https://blog.csdn.net/qq_22613757/article/details/81218741">B树和B+树的区别：</a></p>
<p>B树：每个节点存储M/2到M个关键字，所有关键字在整棵树中出现，且只出现一次，非叶子节点可以命中。</p>
<p>B+树：B+树是B树的变形，为叶子节点增加了链表指针，所有的叶子节点存储关键字，非叶子节点作为叶子节点的索引，B+树总是到叶子节点才命中。</p>
<p>B* 树：在B+树的基础上，增加了非叶子节点的链表指针，将节点的最低利用率从1/2提升到2/3.</p>
]]></content>
  </entry>
  <entry>
    <title>电动车行业分析报告</title>
    <url>/2021/3SFJ041/</url>
    <content><![CDATA[<h1 id="电动车行业分析报告"><a href="#电动车行业分析报告" class="headerlink" title="电动车行业分析报告"></a>电动车行业分析报告</h1><h2 id="1、历史"><a href="#1、历史" class="headerlink" title="1、历史"></a>1、历史</h2><p>​    1832年-1839年之间，历史上第一辆电动车问世。经过多年的改进与发展，到了1900年，欧美国家销售的4200辆车中，电动车占比高达38%，另外40%是蒸汽车，剩下22%才是燃油车。当时燃油车主要还是采用外燃设计，滚滚的浓烟让购买汽车奢侈品的上层贵族们嗤之以鼻。</p>
<p>​    20世纪初期，内燃机的出现让燃油车市场占有率大幅提升。由于搭载内燃机的汽车跑的更远，续航焦虑让人们慢慢抛弃了电动车，电动车暂时告别了汽车的舞台。</p>
<p>​    20世纪60年代，全球处在石油危机的现实面前。人们也开始意识到工业化污染带来的严重影响，电动车慢慢地回归人们的视线中。此时电动车驱动技术的发展也让一些小型的电动车走进人们的生活。</p>
<p>​    20世纪90年代，受限于电池技术，充电和续航仍然是电动车发展的首要矛盾。车企开始转向插电混动，以此来克服里程焦虑。其中主要的技术包括PHEV插电混动和HEV混合动力。</p>
<p>​    21世纪初期，电池密度提升，电动车的续航以每年50公里增长。电动车的前景开始慢慢明朗起来，2003年，马丁·艾伯哈德和马克·塔彭宁创立特斯拉，2004年，埃隆·马斯克加入特斯拉，历史的脚步开始走向另外一个方向。</p>
<h2 id="2、发展"><a href="#2、发展" class="headerlink" title="2、发展"></a>2、发展</h2><h3 id="特斯拉"><a href="#特斯拉" class="headerlink" title="特斯拉"></a>特斯拉</h3><p>​            <img src="/Users/xs/Documents/%E6%8A%80%E6%9C%AF/hexo/source/_posts/%E7%94%B5%E5%8A%A8%E8%BD%A6%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/%E7%89%B9%E6%96%AF%E6%8B%89%E9%94%80%E9%87%8F.png"><img src="/Users/xs/Documents/%E6%8A%80%E6%9C%AF/hexo/source/_posts/%E7%94%B5%E5%8A%A8%E8%BD%A6%E8%A1%8C%E4%B8%9A%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/2020%E5%B9%B4%E5%85%A8%E7%90%83%E4%B8%BB%E8%A6%81%E8%BD%A6%E4%BC%81%E9%94%80%E9%87%8F.png" alt="2020年全球主要车企销量"></p>
<p>​    这几年，电动汽车行业最受关注的企业是特斯拉。从数据上看，特斯拉的销量要远低于各大车企，然而特斯拉的市值截止2021年4月6日收盘已经达6633亿美元，超过九大车企市值总和。</p>
]]></content>
  </entry>
</search>
